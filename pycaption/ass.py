import base64
import tempfile

from pycaption.base import CaptionSet
from pycaption.subtitler_image_based import SubtitleImageBasedWriter


# ASS/SSA format header template
HEADER = """[Script Info]
; Script generated by pycaption ASSWriter
Title: {title}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.709
PlayResX: {play_res_x}
PlayResY: {play_res_y}

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,2,0,0,0,1

"""

# Graphics section for embedded images (base64 encoded)
GRAPHICS_HEADER = """[Graphics]
"""

GRAPHICS_ENTRY = """filename: {filename}
{data}

"""

EVENTS_HEADER = """[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

# Picture event at position 0,0 for full-screen coverage
PICTURE_EVENT = """Picture: 0,{start},{end},Default,,0,0,0,,{filename},0,0,100,100,0
"""


def uuencode_ass(data: bytes) -> str:
    """
    Encode binary data in base64 format for ASS embedding.

    Each line contains up to 60 characters of base64 data.
    """
    result = []
    encoded = base64.b64encode(data).decode('ascii')
    for i in range(0, len(encoded), 60):
        result.append(encoded[i:i + 60])
    return '\n'.join(result)


class ASSWriter(SubtitleImageBasedWriter):
    """
    Advanced SubStation Alpha (ASS) writer for image-based subtitles.

    Generates an ASS file with embedded images in the [Graphics] section.
    The images are base64-encoded and referenced via Picture events.

    By default, generates Full HD (1920x1080) images. The PlayResX/PlayResY
    values match the image dimensions, so ASS-compatible players will
    automatically scale the images to fit the actual video dimensions.

    Uses PNG format for images (best compatibility with libass/FFmpeg/VSFilter).
    PNG with 4-color indexed palette compresses very well (~6 KB per Full HD image).

    This format is compatible with players that support ASS embedded graphics
    (such as VSFilter, libass, VLC, mpv, FFmpeg, and various subtitle editors).
    """

    def __init__(self, relativize=True, video_width=1920, video_height=1080,
                 fit_to_screen=True, frame_rate=25, title='Subtitles'):
        """
        Initialize the ASS writer.

        :param relativize: Convert absolute positioning to percentages
        :param video_width: Width of generated subtitle images (default: 1920 for Full HD)
        :param video_height: Height of generated subtitle images (default: 1080 for Full HD)
        :param fit_to_screen: Ensure captions fit within screen bounds
        :param frame_rate: Frame rate for timing calculations
        :param title: Title to include in ASS metadata
        """
        super().__init__(relativize, video_width, video_height, fit_to_screen, frame_rate)
        self.title = title

    def save_image(self, tmp_dir, index, img):
        """Save subtitle image as optimized PNG with transparency."""
        # PNG with indexed palette: best compatibility with libass/FFmpeg/VSFilter
        # 4-color palette compresses very well (~6 KB for Full HD)
        img.save(
            tmp_dir + '/subtitle%04d.png' % index,
            transparency=3,
            optimize=True,
            compress_level=9
        )

    def format_ts(self, value):
        """
        Format timestamp in ASS format: H:MM:SS.cc (centiseconds)

        ASS uses centiseconds (1/100th of a second) not milliseconds.

        :param value: Time in microseconds
        :return: Formatted timestamp string
        """
        total_seconds = value / 1_000_000
        hours = int(total_seconds // 3600)
        minutes = int((total_seconds % 3600) // 60)
        seconds = int(total_seconds % 60)
        centiseconds = int((total_seconds * 100) % 100)

        return f"{hours}:{minutes:02d}:{seconds:02d}.{centiseconds:02d}"

    def write(
            self,
            caption_set: CaptionSet,
            position='bottom',
            avoid_same_next_start_prev_end=False,
            align='center'
    ):
        """
        Write captions to ASS format with embedded full-screen image-based subtitles.

        Images are generated at the configured resolution (default Full HD 1920x1080)
        and positioned at 0,0 to cover the entire frame. ASS-compatible players will
        automatically scale the images to match the actual video dimensions based on
        PlayResX/PlayResY values.

        :param caption_set: CaptionSet containing the captions to write
        :param position: Position of subtitles ('top', 'bottom', 'source')
        :param avoid_same_next_start_prev_end: Adjust timing to avoid overlaps
        :param align: Text alignment ('left', 'center', 'right')
        :return: ASS file contents as string with embedded PNG images
        """
        lang = caption_set.get_languages().pop()
        caps = caption_set.get_captions(lang)

        with tempfile.TemporaryDirectory() as tmpDir:
            caps_final, overlapping = self.write_images(
                caps, lang, tmpDir, position, align, avoid_same_next_start_prev_end
            )

            # Build ASS content
            # PlayResX/PlayResY define the coordinate system - images will be scaled
            # to fit the actual video dimensions by ASS-compatible players
            ass_content = HEADER.format(
                title=self.title,
                play_res_x=self.video_width,
                play_res_y=self.video_height
            )

            # Add Graphics section with embedded images
            ass_content += GRAPHICS_HEADER
            for i in range(1, len(caps_final) + 1):
                img_path = tmpDir + '/subtitle%04d.png' % i
                with open(img_path, 'rb') as img_file:
                    img_data = img_file.read()
                    encoded_data = uuencode_ass(img_data)
                    ass_content += GRAPHICS_ENTRY.format(
                        filename='subtitle%04d.png' % i,
                        data=encoded_data
                    )

            # Add Events section
            # Picture events positioned at 0,0 with 100% scale to cover full frame
            ass_content += EVENTS_HEADER
            index = 1
            for cap_list in caps_final:
                start_ts = self.format_ts(cap_list[0].start)
                end_ts = self.format_ts(cap_list[0].end)
                filename = 'subtitle%04d.png' % index

                ass_content += PICTURE_EVENT.format(
                    start=start_ts,
                    end=end_ts,
                    filename=filename
                )
                index += 1

        return ass_content
